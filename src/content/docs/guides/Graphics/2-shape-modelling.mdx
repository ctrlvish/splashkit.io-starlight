---
title: Shape Modelling
description: This guide introduces the functions for managing shapes in graphical applications built with SplashKit. We will discuss how to use the API in SplashKit to create graphical application tools.
category: Guides
author: Yuyang Yang and Vishnu
lastupdated: Aug 20 2025
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

**{frontmatter.description}**  
Written by: {frontmatter.author}  
_Last updated: {frontmatter.lastupdated}_

---

In this guide, you’ll learn how to create and manage graphics in SplashKit, including shape creation, movement, resizing, and connecting shapes with lines.


## Graphics creation and Management
In this section, we'll detail how to implement the shape creation and management functionality using design patterns and code examples.


### Model Design
We start by defining a ShapeModel structure to represent various basic shapes. This model holds attributes like position, size, color, and shape type.
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
struct ShapeModel
{
    double x, y;          // Shape's starting position
    double width, height; // Shape's width and height
    string color;         // Shape's color
    double rotation;      // Shape's rotation angle
    string type;          // Shape type (Rectangle, Circle, Triangle, etc.)
};
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
public struct ShapeModel
{
    public double X, Y;            // Shape's starting position
    public double Width, Height;   // Shape's width and height
    public string Color;           // Shape's color
    public double Rotation;        // Shape's rotation angle
    public string Type;            // Shape type (Rectangle, Circle, Triangle, etc.)
}
```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
public struct ShapeModel
{
    public double X, Y;            // Shape's starting position
    public double Width, Height;   // Shape's width and height
    public string Color;           // Shape's color
    public double Rotation;        // Shape's rotation angle
    public string Type;            // Shape type (Rectangle, Circle, Triangle, etc.)
}
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
class ShapeModel:
    def __init__(self):
        self.x = 0.0            # Shape's starting position
        self.y = 0.0
        self.width = 0.0        # Shape's width and height
        self.height = 0.0
        self.color = ""         # Shape's color
        self.rotation = 0.0     # Shape's rotation angle
        self.type = ""          # Shape type (Rectangle, Circle, Triangle, etc.)

```
</TabItem>
</Tabs>
The `ShapeModel` can represent various shapes like rectangles, triangles, etc. The `type` field is used to distinguish between different shapes, allowing the correct drawing function to be called during rendering.

### Shape Creation
The code simulates the user selecting a graphic and placing it on the canvas. When the user clicks on the canvas, the code creates a new graphic at the mouse position based on the preset shape type
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
if (mouse_clicked(LEFT_BUTTON))
{
    ShapeModel newShape;
    newShape.x = mouse_x();   // Get the X coordinate of the mouse
    newShape.y = mouse_y();   // Get the Y coordinate of the mouse
    newShape.width = 100;     // Set default width
    newShape.height = 100;    // Set default height
    newShape.color = "Red";   // Set default color
    newShape.type = "Rectangle";  // Set default type to Rectangle
    shapes.push_back(newShape);   // Add the new shape to the shapes container
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
if (MouseClicked(MouseButton.LeftButton))
{
    ShapeModel newShape;
    newShape = new ShapeModel();
    newShape.x = mouse_x();   // Get the X coordinate of the mouse
    newShape.y = mouse_y();   // Get the Y coordinate of the mouse
    newShape.width = 100;     // Set default width
    newShape.height = 100;    // Set default height
    newShape.color = "Red";   // Set default color
    newShape.type = "Rectangle";  // Set default type to Rectangle
    shapes.Add(newShape);   // Add the new shape to the shapes container
}
```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
if (SplashKit.MouseClicked(MouseButton.LeftButton))
{
    ShapeModel newShape;
    newShape = new ShapeModel();
    newShape.x = mouse_x();   // Get the X coordinate of the mouse
    newShape.y = mouse_y();   // Get the Y coordinate of the mouse
    newShape.width = 100;     // Set default width
    newShape.height = 100;    // Set default height
    newShape.color = "Red";   // Set default color
    newShape.type = "Rectangle";  // Set default type to Rectangle
    shapes.Add(newShape);   // Add the new shape to the shapes container
}
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
if mouse_clicked(left_button):
    new_shape = ShapeModel()
    new_shape.x = mouse_x()   # Get the X coordinate of the mouse
    new_shape.y = mouse_y()   # Get the Y coordinate of the mouse
    new_shape.width = 100     # Set default width
    new_shape.height = 100    # Set default height
    new_shape.color = "Red"   # Set default color
    new_shape.type = "Rectangle"  # Set default type to Rectangle
    shapes.append(new_shape)   # Add the new shape to the shapes container
```
</TabItem>
</Tabs>

### Shape Management and Rendering
We can manage rendering by iterating through the shape collection and calling the appropriate drawing function based on the shape’s type.
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
clear_screen(COLOR_WHITE);

for (int i = 0; i < shapes.size(); i++)
{
    fill_rectangle(COLOR_RED, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
}

refresh_screen(60);
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
ClearScreen(ColorWhite());

for (int i = 0; i < shapes.Count; i++)
{
    FillRectangle(ColorRed(), shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
}

RefreshScreen(60);
```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
SplashKit.ClearScreen(Color.White);

for (int i = 0; i < shapes.Count; i++)
{
    SplashKit.FillRectangle(Color.Red, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
}

SplashKit.RefreshScreen(60);
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
clear_screen(color_white())

for i in range(len(shapes)):
    fill_rectangle(
        color_red(), shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height)

refresh_screen(60)
```
</TabItem>
</Tabs>

###  Code example
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"
#include <vector>

struct ShapeModel
{
    double x, y;
    double width, height;
    string color;
    double rotation;
    string type;
};

int main()
{
    open_window("Drawing Test", 800, 600);
    vector<ShapeModel> shapes;

    while (!window_close_requested("Drawing Test"))
    {
        process_events();

        if (mouse_clicked(LEFT_BUTTON))
        {
            ShapeModel newShape;
            newShape.x = mouse_x();
            newShape.y = mouse_y();
            newShape.width = 100;
            newShape.height = 100;
            newShape.color = "Red";
            newShape.type = "Rectangle";
            shapes.push_back(newShape);
        }

        clear_screen(COLOR_WHITE);

        for (int i = 0; i < shapes.size(); i++)
        {
            fill_rectangle(COLOR_RED, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
        }

        refresh_screen(60);
    }

    return 0;
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
using SplashKitSDK;
using static SplashKitSDK.SplashKit;

OpenWindow("Drawing Test", 800, 600);
List<ShapeModel> shapes = new List<ShapeModel>();

while (!QuitRequested())
{
    ProcessEvents();

    if (MouseClicked(MouseButton.LeftButton))
    {
        ShapeModel newShape = new ShapeModel();
        newShape.x = MouseX();
        newShape.y = MouseY();
        newShape.width = 100;
        newShape.height = 100;
        newShape.color = "Red";
        newShape.type = "Rectangle";
        shapes.Add(newShape);
    }

    ClearScreen(ColorWhite());

    for (int i = 0; i < shapes.Count; i++)
    {
        FillRectangle(ColorRed(), shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
    }

    RefreshScreen(60);
}

CloseAllWindows();

public struct ShapeModel
{
    public double x, y;
    public double width, height;
    public string color;
    public double rotation;
    public string type;
}

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
using SplashKitSDK;

namespace ShapeModelling
{
    public class Program
    {
        public struct ShapeModel
        {
            public double x, y;
            public double width, height;
            public string color;
            public double rotation;
            public string type;
        }
        public static void Main()
        {
            SplashKit.OpenWindow("Drawing Test", 800, 600);
            List<ShapeModel> shapes = new List<ShapeModel>();

            while (!SplashKit.QuitRequested())
            {
                SplashKit.ProcessEvents();

                if (SplashKit.MouseClicked(MouseButton.LeftButton))
                {
                    ShapeModel newShape = new ShapeModel();
                    newShape.x = SplashKit.MouseX();
                    newShape.y = SplashKit.MouseY();
                    newShape.width = 100;
                    newShape.height = 100;
                    newShape.color = "Red";
                    newShape.type = "Rectangle";
                    shapes.Add(newShape);
                }

                SplashKit.ClearScreen(Color.White);

                for (int i = 0; i < shapes.Count; i++)
                {
                    SplashKit.FillRectangle(Color.Red, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
                }

                SplashKit.RefreshScreen(60);
            }

            SplashKit.CloseAllWindows();
        }
    }
}

```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
from splashkit import *


class ShapeModel:
    def __init__(self):
        self.x = 0.0
        self.y = 0.0
        self.width = 0.0
        self.height = 0.0
        self.color = ""
        self.rotation = 0.0
        self.type = ""


open_window("Drawing Test", 800, 600)
shapes = []

while not quit_requested():
    process_events()

    if mouse_clicked(MouseButton.left_button):
        newShape = ShapeModel()
        newShape.x = mouse_x()
        newShape.y = mouse_y()
        newShape.width = 100
        newShape.height = 100
        newShape.color = "Red"
        newShape.type = "Rectangle"
        shapes.append(newShape)

    clear_screen(rgb_color(255, 255, 255))

    for i in range(len(shapes)):
        fill_rectangle(rgb_color(
            255, 0, 0), shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height)

    refresh_screen_with_target_fps(60)

close_all_windows()

```
</TabItem>
</Tabs>


## Graphical operations 
In this section, we’ll discuss how to handle the selection and movement of shapes. The code is designed to allow users to select shapes, move them around the canvas, and resize them. This approach makes the code more modular, easier to maintain, and extend.

### Detect Shape Selection
  First, we need to determine which shape the user has clicked on. This is achieved by checking if the mouse click position falls within the bounds of any existing shape. The `get_shape_at()` function is used to detect whether the mouse click is within a shape, allowing the program to identify which shape, if any, the user has selected.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
ShapeModel* get_shape_at(vector<ShapeModel>& shapes, double x, double y)
{
    for (int i = 0; i < shapes.size(); i++)
    {
        if (shapes[i].type == "Rectangle" && x >= shapes[i].x && x <= (shapes[i].x + shapes[i].width) && y >= shapes[i].y && y <= (shapes[i].y + shapes[i].height))
        {
            return &shapes[i];
        }
    }
    return nullptr; 
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>


### Dragging Shapes
  Once a shape is selected, the user can drag it by moving the mouse. This is done by updating the shape's x and y coordinates to follow the mouse's movement. The `is_moving` flag is used to distinguish between creating a new shape and moving an existing shape.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
if (is_moving && selected_shape != nullptr)
{
    selected_shape->x = mouse_x() - selected_shape->width / 2;
    selected_shape->y = mouse_y() - selected_shape->height / 2;
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>
  
### Resizing Shapes
  In addition to dragging, users can resize shapes. Holding down the SPACE key while clicking a shape activates resizing mode. The shape’s width and height update dynamically based on the mouse position.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
if (is_resizing && selected_shape != nullptr)
{
    selected_shape->width = mouse_x() - selected_shape->x;
    selected_shape->height = mouse_y() - selected_shape->y;
}

```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>

### Final Shape Position
 When the user releases the mouse button, the dragging or resizing operation stops, and the shape's final position or size is confirmed.

###  Code example
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"
#include <vector>

struct ShapeModel
{
    double x, y;
    double width, height;
    string color;
    double rotation;
    string type;
};

ShapeModel *get_shape_at(vector<ShapeModel> &shapes, double x, double y)
{
    for (int i = 0; i < shapes.size(); i++)
    {
        if (shapes[i].type == "Rectangle" && x >= shapes[i].x && x <= (shapes[i].x + shapes[i].width) && y >= shapes[i].y && y <= (shapes[i].y + shapes[i].height))
        {
            return &shapes[i];
        }
    }
    return nullptr;
}

int main()
{
    open_window("Drawing Test", 800, 600);
    vector<ShapeModel> shapes;
    ShapeModel *selected_shape = nullptr;
    bool is_moving = false;
    bool is_resizing = false;

    while (!window_close_requested("Drawing Test"))
    {
        process_events();

        if (!is_moving && !is_resizing)
        {
            if (mouse_down(LEFT_BUTTON))
            {
                selected_shape = get_shape_at(shapes, mouse_x(), mouse_y());
                if (selected_shape != nullptr)
                {
                    if (key_down(SPACE_KEY))
                    {
                        is_resizing = true;
                    }
                    else
                    {
                        is_moving = true;
                    }
                }
                else
                {
                    ShapeModel newShape;
                    newShape.x = mouse_x();
                    newShape.y = mouse_y();
                    newShape.width = 100;
                    newShape.height = 100;
                    newShape.color = "Red";
                    newShape.type = "Rectangle";
                    shapes.push_back(newShape);
                }
            }
        }

        if (is_moving && selected_shape != nullptr)
        {
            selected_shape->x = mouse_x() - selected_shape->width / 2;
            selected_shape->y = mouse_y() - selected_shape->height / 2;
        }

        if (is_resizing && selected_shape != nullptr)
        {
            selected_shape->width = mouse_x() - selected_shape->x;
            selected_shape->height = mouse_y() - selected_shape->y;
        }

        if (mouse_up(LEFT_BUTTON))
        {
            is_moving = false;
            is_resizing = false;
            selected_shape = nullptr;
        }

        clear_screen(COLOR_WHITE);

        for (int i = 0; i < shapes.size(); i++)
        {
            if (shapes[i].type == "Rectangle")
            {
                fill_rectangle(COLOR_RED, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
            }
        }

        refresh_screen(60);
    }

    return 0;
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>

## Wiring function 

In this section, we’ll add connection lines so users can visually link two shapes. Here’s how to implement it.

In this feature, we use the `state mode` to handle the connections between shapes. State mode allows us to perform different operations in different states, such as connection mode and normal mode. Encapsulating the connection state in a class or function makes the process clearer and allows easy switching between modes.

### Define the Shape Model
We first define a basic shape structure `ShapeModel`, which contains properties such as `x`, `y` coordinates, `width`, `height`, color, and type.

### Mouse Interaction with Shapes
We use the `get_shape_at` function to detect whether the mouse is over a shape. It loops through the list of shapes and checks if the mouse coordinates fall within any shape's boundaries.

### Activate Connection Mode
To start connecting shapes, we press the **C key**. This switches the program into connection mode, allowing the user to choose two shapes to connect with a line.
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
if (key_down(C_KEY) && !is_connecting)
{
    is_connecting = true;
    connection_start = nullptr;
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>

### Set Start and End Points for Connection
While in connection mode, when the user clicks on a shape, it records the starting point (`connection_start`). The next click sets the end point (`connection_end`). Once both are selected, a connection is stored.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
if (is_connecting)
{
    if (mouse_down(LEFT_BUTTON))
    {
        if (connection_start == nullptr)
        {
            connection_start = get_shape_at(shapes, mouse_x(), mouse_y());
        }
        else
        {
            ShapeModel* connection_end = get_shape_at(shapes, mouse_x(), mouse_y());
            if (connection_end != nullptr && connection_end != connection_start)
            {
                connections.push_back({ connection_start, connection_end });
                is_connecting = false; // End connection mode
                connection_start = nullptr;
            }
        }
    }
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>

### Draw Lines between Shapes
Using the `draw_line` function, we draw lines between the center points of the two selected shapes. This line is visually updated in real time during the connection process.
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
for (const auto& conn : connections)
{
    draw_line(COLOR_RED, conn.start->x + conn.start->width / 2, conn.start->y + conn.start->height / 2,
                 conn.end->x + conn.end->width / 2, conn.end->y + conn.end->height / 2);
}

```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>

### Exit Connection Mode
After a connection is drawn, the program exits connection mode and returns to normal interaction.

This implementation creates an intuitive and interactive way for users to connect shapes, simulating links between objects.

###  Code example
<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
#include "splashkit.h"
#include <vector>

struct ShapeModel
{
    double x, y;
    double width, height;
    string color;
    double rotation;
    string type;
};

struct Connection
{
    ShapeModel *start;
    ShapeModel *end;
};

ShapeModel *get_shape_at(vector<ShapeModel> &shapes, double x, double y)
{
    for (int i = 0; i < shapes.size(); i++)
    {
        if (shapes[i].type == "Rectangle" && x >= shapes[i].x && x <= (shapes[i].x + shapes[i].width) && y >= shapes[i].y && y <= (shapes[i].y + shapes[i].height))
        {
            return &shapes[i];
        }
    }
    return nullptr;
}

int main()
{
    open_window("Drawing Test", 800, 600);
    vector<ShapeModel> shapes;
    vector<Connection> connections;
    ShapeModel *selected_shape = nullptr;
    ShapeModel *connection_start = nullptr;
    bool is_moving = false;
    bool is_resizing = false;
    bool is_connecting = false;

    while (!window_close_requested("Drawing Test"))
    {
        process_events();

        if (key_down(C_KEY) && !is_connecting)
        {
            is_connecting = true;
            connection_start = nullptr;
        }

        if (is_connecting)
        {
            if (mouse_down(LEFT_BUTTON))
            {
                if (connection_start == nullptr)
                {
                    connection_start = get_shape_at(shapes, mouse_x(), mouse_y());
                }
                else
                {
                    ShapeModel *connection_end = get_shape_at(shapes, mouse_x(), mouse_y());
                    if (connection_end != nullptr && connection_end != connection_start)
                    {
                        Connection connection = {connection_start, connection_end};
                        connections.push_back(connection);
                        is_connecting = false;
                        connection_start = nullptr;
                    }
                }
            }
        }
        else if (!is_moving && !is_resizing)
        {
            if (mouse_down(LEFT_BUTTON))
            {
                selected_shape = get_shape_at(shapes, mouse_x(), mouse_y());
                if (selected_shape != nullptr)
                {
                    if (key_down(SPACE_KEY))
                    {
                        is_resizing = true;
                    }
                    else
                    {
                        is_moving = true;
                    }
                }
                else
                {
                    ShapeModel newShape;
                    newShape.x = mouse_x();
                    newShape.y = mouse_y();
                    newShape.width = 100;
                    newShape.height = 100;
                    newShape.color = "Red";
                    newShape.type = "Rectangle";
                    shapes.push_back(newShape);
                }
            }
        }

        if (is_moving && selected_shape != nullptr)
        {
            selected_shape->x = mouse_x() - selected_shape->width / 2;
            selected_shape->y = mouse_y() - selected_shape->height / 2;
        }

        if (is_resizing && selected_shape != nullptr)
        {
            selected_shape->width = mouse_x() - selected_shape->x;
            selected_shape->height = mouse_y() - selected_shape->y;
        }

        if (mouse_up(LEFT_BUTTON))
        {
            is_moving = false;
            is_resizing = false;
            selected_shape = nullptr;
        }

        clear_screen(COLOR_WHITE);

        for (int i = 0; i < shapes.size(); i++)
        {
            if (shapes[i].type == "Rectangle")
            {
                fill_rectangle(COLOR_RED, shapes[i].x, shapes[i].y, shapes[i].width, shapes[i].height);
            }
        }

        if (is_connecting && connection_start != nullptr)
        {
            draw_line(COLOR_BLACK, connection_start->x + connection_start->width / 2, connection_start->y + connection_start->height / 2, mouse_x(), mouse_y());
        }

        for (int i = 0; i < connections.size(); i++)
        {
            draw_line(COLOR_RED, connections[i].start->x + connections[i].start->width / 2, connections[i].start->y + connections[i].start->height / 2, connections[i].end->x + connections[i].end->width / 2, connections[i].end->y + connections[i].end->height / 2);
        }

        refresh_screen(60);
    }

    return 0;
}
```
</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp

```
</TabItem>
<TabItem label="Object-Oriented">

```csharp
```
</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
```
</TabItem>
</Tabs>


